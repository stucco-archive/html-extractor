package HTMLExtractor;

import java.util.ArrayList;
import java.util.Random;
import java.util.TreeSet;

import org.json.*;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.mitre.stix.stix_1.STIXHeaderType;
import org.mitre.stix.stix_1.STIXPackage;
import org.mitre.stix.ttp_1.BehaviorType;
import org.mitre.stix.ttp_1.MalwareType;
import org.mitre.stix.ttp_1.MalwareInstanceType;
import org.mitre.stix.common_1.ControlledVocabularyStringType;
import org.mitre.stix.stix_1.IndicatorsType;
import org.mitre.stix.common_1.IndicatorBaseType;
import org.mitre.stix.indicator_2.Indicator;
import org.mitre.stix.indicator_2.ValidTimeType;
import org.mitre.stix.ttp_1.VictimTargetingType;
import org.mitre.stix.ttp_1.ResourceType;
import org.mitre.stix.ttp_1.ToolsType;
import org.mitre.stix.common_1.ToolInformationType;
import org.mitre.stix.ttp_1.InfrastructureType;
import org.mitre.stix.common_1.StructuredTextType;
import org.mitre.stix.indicator_2.SuggestedCOAsType;
import org.mitre.stix.common_1.RelatedCourseOfActionType;
import org.mitre.stix.common_1.CourseOfActionBaseType;
import org.mitre.stix.courseofaction_1.CourseOfAction;
import org.mitre.cybox.cybox_2.Observable;
import org.mitre.stix.common_1.InformationSourceType;
import org.mitre.stix.common_1.ContributingSourcesType;
import org.mitre.stix.common_1.IdentityType;
import org.mitre.cybox.common_2.TimeType;
import org.mitre.stix.common_1.TTPBaseType;
import org.mitre.stix.ttp_1.TTP;
import org.mitre.stix.common_1.RelatedTTPType;
import org.mitre.stix.ttp_1.BehaviorType;
import org.mitre.stix.ttp_1.AttackPatternsType;
import org.mitre.stix.ttp_1.AttackPatternType;
import org.mitre.stix.common_1.DateTimeWithPrecisionType;
import org.mitre.stix.common_1.ReferencesType;
import org.mitre.cybox.objects.DNSRecord;
import org.mitre.cybox.objects.URIObjectType;
import org.mitre.cybox.common_2.AnyURIObjectPropertyType;
import org.mitre.cybox.cybox_2.ObjectType;
import org.mitre.cybox.common_2.ObjectPropertiesType;
import org.mitre.cybox.common_2.CustomPropertiesType;
import org.mitre.cybox.common_2.Property;
import org.mitre.cybox.common_2.MeasureSourceType;
import org.mitre.cybox.cybox_2.Observables;
import org.mitre.cybox.objects.Address;
import org.mitre.cybox.common_2.StringObjectPropertyType;
import org.mitre.cybox.objects.CategoryTypeEnum;

import javax.xml.datatype.XMLGregorianCalendar;
import javax.xml.datatype.DatatypeFactory;
import javax.xml.namespace.QName;
import java.util.GregorianCalendar;
import java.util.TimeZone;
import java.util.UUID;
import javax.xml.datatype.DatatypeConfigurationException;

import org.xml.sax.SAXException;

public class MalwareDomainListToStixExtractor extends HTMLExtractor{
	
	private STIXPackage stixPackage;
											
	private static final Logger logger = LoggerFactory.getLogger(MalwareDomainListToStixExtractor.class);

	public MalwareDomainListToStixExtractor(String content){
		stixPackage = extract(content);
	}
					
	public STIXPackage getStixPackage() {
		return stixPackage;
	}
	
	private long convertTimestamp(String time)	{ 
		return convertTimestamp(time + " (GMT)", "yyyy/MM/dd_hh:mm (z)");
	}
	
	private STIXPackage extract(String content){
	
		try {

		MalwareInstanceType malware = new MalwareInstanceType();
		IndicatorsType indicators = new IndicatorsType();
		InformationSourceType source = new InformationSourceType();
		Observables observables = new Observables();
		GregorianCalendar calendar = new GregorianCalendar();
		XMLGregorianCalendar now = DatatypeFactory.newInstance().newXMLGregorianCalendar(				
			new GregorianCalendar(TimeZone.getTimeZone("UTC")));
		stixPackage = new STIXPackage()				
 			.withSTIXHeader(new STIXHeaderType().
				withTitle("MalwareDomainList")) 
			.withTimestamp(now)
 			.withId(new QName("stucco", "MalwareDomainList-" + UUID.randomUUID().toString(), "stucco"));
								
		Document doc = Jsoup.parse(content);
		Element contentBox = doc.getElementsByClass("ContentBox").first();
		logger.debug(contentBox.html());
		
		Element table = contentBox.getElementsByTag("table").last();
		logger.debug("Table Contents: {}", table.outerHtml());
		
		Element headers = table.getElementsByClass("tabletitle").first();
		Elements colTitlesElements = headers.getElementsByTag("td");
		ArrayList<String> colTitles = new ArrayList<String>();
		String currTitle;
		for(int i=0; i<colTitlesElements.size()-1; i++){
			currTitle = colTitlesElements.get(i).text();
			colTitles.add(currTitle);
		}
		colTitles.add("Country"); //last col has flag icons, with no headers.
		logger.info("Col titles found: {}", colTitles);
		
		Elements rows = table.getElementsByTag("tr");
		rows.remove(0); //remove the two header rows
		rows.remove(0);
		logger.debug("Table rows remaining: {}", rows.outerHtml());
		
		String cells[][] = getCells(rows);
		
		TreeSet<Long> date = new TreeSet<Long>();
		TreeSet<String> urls = new TreeSet<String>();
		TreeSet<String> domain = new TreeSet<String>();
		TreeSet<String> ips = new TreeSet<String>();
		TreeSet<String> reverse_lookup = new TreeSet<String>();
		TreeSet<String> description = new TreeSet<String>();
		TreeSet<String> registrant = new TreeSet<String>();
		TreeSet<String> asn = new TreeSet<String>();
		TreeSet<String> country = new TreeSet<String>();
		
		for(int i=0; i<cells.length; i++){
			String desc = cells[i][4];
			if(desc.equals("-")) desc = "";
			String possibleAVName;
			if(cells[i].length != 8){
				logger.warn("Unexpected length of cells[" + i + "]: " + cells[i].length);
			}

			date.add( convertTimestamp(cells[i][0]));
			if(cells[i][1].equals("-")){//no 'domain' field, which means 'ip' field will contain the actual url
				String urlString = cells[i][2];
				if(urlString.contains(" ")){ //sometimes, the URL field actually contains URL, space, AVName
					possibleAVName = urlString.split(" ")[1];
					//Somewhere around 2% have this, and almost all are missing their desc. field.
					logger.info("Possible AVName found: " + possibleAVName + " from url " + urlString);
					if(desc.length() >0){
						logger.info("previous description was {}", desc);
						desc = possibleAVName + " " + desc;  //Note: this is somewhere around 0.1%
					}else{
						desc = possibleAVName;
					}
					//logger.info(desc);
					urlString = urlString.split(" ")[0];
				}
				urls.add(urlString);
				try {
					String currIP = getDomainFromURL("http://"+urlString); 
					ips.add(currIP);
				} catch (Exception e) {
					logger.warn("Unparsable URL: " + cells[i][2], e);
				}
			}else{
				String urlString = cells[i][1];
				if(urlString.contains(" ")){ //sometimes, the URL field actually contains URL, space, AVName
					possibleAVName = urlString.split(" ")[1];
					//Somewhere around 2% have this, and almost all are missing their desc. field.
					logger.info("Possible AVName found: " + possibleAVName + " from url " + urlString);
					if(desc.length() >0){
						logger.info("previous description was {}", desc);
						desc = possibleAVName + " " + desc;  //Note: this is somewhere around 0.1%
					}else{
						desc = possibleAVName;
					}
					//logger.info(desc);
					urlString = urlString.split(" ")[0];
				}
				urls.add(urlString);
				try {
					String currDomain = getDomainFromURL("http://"+urlString); 
					domain.add(currDomain);
				} catch (java.net.URISyntaxException e) {
					logger.warn("Unparsable URL: " + cells[i][1]);
				}
				ips.add(cells[i][2]);
			}
			reverse_lookup.add(cells[i][3]);
			description.add(desc);
			registrant.add(cells[i][5]);
			asn.add(cells[i][6]);
			country.add(cells[i][7]);
		}
		
// ------------------------------------------------------------------------------------------------------
		
		//malware node stuff...
		String malwareName = "MalwareDomainList_";
		Indicator indicator = new Indicator();
		ToolsType tools = new ToolsType();

		if(domain.size() == 1) malwareName += domain.first();
		else if(ips.size() == 1) malwareName += ips.first();
		else{
			logger.warn("No meaningful name could be generated!");
			Random r = new Random();
			malwareName += r.nextInt(1000000000);//TODO any better ideas?
		}

		//name as Indicator->TTP->Behavior->Malware->name
		malware
			.withNames(new ControlledVocabularyStringType()
				.withValue(malwareName));

		if(date.size() == 1){
			
			calendar.setTimeInMillis(date.first());
			XMLGregorianCalendar startDate = DatatypeFactory.newInstance().newXMLGregorianCalendar(calendar);
			
			//date as Indicator->Valid_Time_Position->Start_Time
			indicator
				.withValidTimePositions(new ValidTimeType()
					.withStartTime(new DateTimeWithPrecisionType()
						.withValue(startDate)));
			
		}else{
			logger.warn("Expected to find one date, but found " + date.size());
		}
		if(urls.size() == 0){ //can have more than one
			logger.warn("Expected to find at least one url, but found none!");
		}else{
			for (String url: urls)	{
				tools
					.withTools(new ToolInformationType()
						.withTitle("url")
						.withName(url));
			}
		}
		if(description.size() == 0){ //can have more than one
			logger.warn("Expected to find at least one description, but found none!");
		}else{
			String desc = "";
			for(String item : description){
				desc += item + ", ";
			}
			desc = (String) desc.subSequence(0, desc.length()-2);
			malware
				.withDescriptions(new StructuredTextType()
					.withValue(desc));
		}
		
		//packing malware etc. into indicator	
		indicators
			.withIndicators(indicator
				.withTypes(new ControlledVocabularyStringType()
					.withValue("Malware"))
				.withIndicatedTTPs(new RelatedTTPType()
					.withTTP(new TTP()
						.withBehavior(new BehaviorType()
							.withMalware(new MalwareType()
								.withMalwareInstances(malware)))
						.withInformationSource(new InformationSourceType()
							.withIdentity(new IdentityType()
								.withName("MalwareDomainList")))
						.withResources(new ResourceType()
							.withTools(tools)))));

// --------------------------------------------------------------------------------------------------------

		//DNS node stuff...
		DNSRecord dns = new DNSRecord();

		if(domain.size() > 1){
			logger.warn("Expected to find zero or one domain, but found " + domain.size());
		}else if (domain.size() == 1){
			dns
				.withDomainName(new URIObjectType()
					.withValue(new AnyURIObjectPropertyType()
						.withValue(domain.first())))
				.withDescription(new org.mitre.cybox.common_2. StructuredTextType()
					.withValue(domain.first()));

			if(registrant.size() == 1){
				if(!registrant.first().equals("-"))	{
					dns
						.withCustomProperties(new CustomPropertiesType()
							.withProperties(new Property()
								.withName("Registrant")
								.withValue(registrant.first())));
				}			
					
			}else{
				logger.warn("Expected to find one registrant, but found " + registrant.size());
			}
			
			indicators
				.withIndicators(new Indicator()
					.withTypes(new ControlledVocabularyStringType()
						.withValue("DNSName"))
					.withObservable(new Observable()
						.withObservableSources(new MeasureSourceType()
							.withInformationSourceType(new org.mitre.cybox.common_2.ControlledVocabularyStringType()
								.withValue("MalwareDomainList")))
						.withObject(new ObjectType()
							.withProperties(dns))));
			
			if(ips.size() == 0){
				//if were are no IPs, we would need to make an 'address' node to connect to.
				//HOWEVER I don't think that will ever happen.
				//TODO: if you ever see this message, revisit this issue.
				logger.warn("Did not find any IPs!  Some edges can not be created!");
			}//if there were IPs found, just make the edges later, after the address node(s) are created.			
		//else you have no DNS info, which happens sometimes
		}
								
// -------------------------------------------------------------------------------------------------------------
		
		//reverse DNS stuff...
		if(reverse_lookup.size() == 1){

			indicators
				.withIndicators(new Indicator()
					.withTypes(new ControlledVocabularyStringType()
						.withValue("DNSName"))
					.withObservable(new Observable()
						.withObservableSources(new MeasureSourceType()
							.withInformationSourceType(new org.mitre.cybox.common_2.ControlledVocabularyStringType()
								.withValue("MalwareDomainList")))
						.withObject(new ObjectType()								
							.withProperties(new DNSRecord()
								.withDomainName(new URIObjectType()
									.withValue(new AnyURIObjectPropertyType()
										.withValue(reverse_lookup.first())))
								.withDescription(new org.mitre.cybox.common_2. StructuredTextType()
									.withValue(reverse_lookup.first()))))));
		}else{								
			logger.warn("Expected to find one reverse_lookup, but found " + reverse_lookup.size());
		}
		
// -----------------------------------------------------------------------------------------------------------------		
		//IP node stuff...
		if(ips.size() == 0){ //can have more than one
			logger.warn("Expected to find at least one ip, but found none!");
		}else{
			for(String ip : ips){
				
				indicators
					.withIndicators(new Indicator()
						.withTypes(new ControlledVocabularyStringType()
							.withValue("ip"))
						.withObservable(new Observable()
							.withObservableSources(new MeasureSourceType()
								.withInformationSourceType(new org.mitre.cybox.common_2.ControlledVocabularyStringType()
									.withValue("MalwareDomainList")))
							.withObject(new ObjectType()
								.withDescription(new org.mitre.cybox.common_2.StructuredTextType()
									.withValue(ip)) 
								.withProperties(new Address()
									.withAddressValue(new StringObjectPropertyType()
										.withValue(ip))
									.withCategory(CategoryTypeEnum.IPV_4_ADDR)))));
				
				//asn and country really go in an AddressRange node, 
				//  but we won't know what range to use until alignment can look it up in database
				//TODO: how best to handle this?
				//  leaving it out for now, it *shouldn't* be new info anyway...
				/*
				if(asn.size() == 1){
					ipVertex.put("asNum", asn.first());
				}else{
					logger.warn("Expected to find one asn, but found " + asn.size());
				}		
				if(country.size() == 1){
					ipVertex.put("countryName", country.first());
				}else{
					logger.warn("Expected to find one country, but found " + country.size());
				}
				*/
				
				//NOW we can make the address node(s), and make all of the needed edges
				String addressName = ip + ":80"; //TODO more robust handling
				String addressDesc = ip + ", port 80"; //TODO more robust handling
				if(urls.size() == 0) addressName = ip + ":any"; //should rarely or never happen
				
				indicators
					.withIndicators(new Indicator()
						.withTypes(new ControlledVocabularyStringType()
							.withValue("Address"))
							.withObservable(new Observable()
								.withObservableSources(new MeasureSourceType()
									.withInformationSourceType(new org.mitre.cybox.common_2.ControlledVocabularyStringType()
										.withValue("MalwareDomainList")))
								.withObject(new ObjectType()
									.withDescription(new org.mitre.cybox.common_2.StructuredTextType()
										.withValue(addressDesc)) 
									.withProperties(new Address()
										.withAddressValue(new StringObjectPropertyType()
											.withValue(addressName))
										.withCategory(CategoryTypeEnum.IPV_4_ADDR)))));
															
// ------------------------------------------------------------------------------------------------------------------------------

				//TODO include edges into the stixPackage
				//'malware' -'communicatesWith'-> 'address'
		/*		JSONObject edge = new JSONObject();
				edge.put("_inV", addressName);
				edge.put("_outV", malwareName);
				edge.put("_id", malwareName + "_communicatesWith_" + addressName);
				edge.put("description", malwareName + " communicates with " + addressDesc);
				edge.put("_type", "edge");
				edge.put("inVType", "address");
				edge.put("outVType", "malware");
				edge.put("source", "MalwareDomainList");
				edge.put("_label", "communicatesWith");
				edges.put(edge);
				//"description":"'address' -'hasIP'-> 'IP'",
				edge = new JSONObject();
				edge.put("_inV", ip);
				edge.put("_outV", addressName);
				edge.put("_id", addressName + "_hasIP_" + ip);
				edge.put("description", addressDesc + " has IP " + ip);
				edge.put("_type", "edge");
				edge.put("inVType", "ip");
				edge.put("outVType", "address");
				edge.put("source", "MalwareDomainList");
				edge.put("_label", "hasIP");
				edges.put(edge);
				//TODO 'address' -'hasPort'-> 'port' ??
				//"description":"'address' -'hasDNSName'-> 'DNSName'",
				if(dnsVertex != null){
					edge = new JSONObject();
					edge.put("_inV", dnsVertex.get("name"));
					edge.put("_outV", addressName);
					edge.put("_id", addressName + "_hasDNSName_" + dnsVertex.get("name"));
					edge.put("description", addressDesc + " has DNS name " + dnsVertex.get("name"));
					edge.put("_type", "edge");
					edge.put("inVType", "DNSName");
					edge.put("outVType", "address");
					edge.put("source", "MalwareDomainList");
					edge.put("_label", "hasDNSName");
					edge.put("reverse", false);
					edges.put(edge);
				}
				//"description":"'address' -'hasDNSName'-> 'DNSName'",
				if(reverseDnsVertex != null){
					edge = new JSONObject();
					edge.put("_inV", reverseDnsVertex.get("name"));
					edge.put("_outV", addressName);
					edge.put("_id", addressName + "_hasDNSName_" + reverseDnsVertex.get("name"));
					edge.put("description", addressDesc + " has DNS name " + reverseDnsVertex.get("name"));
					edge.put("_type", "edge");
					edge.put("inVType", "DNSName");
					edge.put("outVType", "address");
					edge.put("source", "MalwareDomainList");
					edge.put("_label", "hasDNSName");
					edge.put("reverse", true);
					edges.put(edge);
				}
		*/
			}
		}
		
		
		stixPackage 											
			.withIndicators(indicators);
							
	    	return stixPackage;

		} catch (DatatypeConfigurationException e)      {
			 e.printStackTrace();
		}
		
		return null;
	}

	boolean validate(STIXPackage stixPackage) {
		
		try     {
	        	return stixPackage.validate();
		}catch (SAXException e)  {
			e.printStackTrace();
		}
		
		return false;
	}


}
