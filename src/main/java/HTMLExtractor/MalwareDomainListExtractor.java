package HTMLExtractor;

import java.util.ArrayList;
import java.util.Random;
import java.util.TreeSet;

import org.json.*;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class MalwareDomainListExtractor extends HTMLExtractor{
	
	private JSONObject graph;
	private static final Logger logger = LoggerFactory.getLogger(MalwareDomainListExtractor.class);

	public MalwareDomainListExtractor(String content){
		graph = extract(content);
	}
	
	public JSONObject getGraph() {
		return graph;
	}
	
	private long convertTimestamp(String time)	{ 
		return convertTimestamp(time, "yyyy/MM/dd_hh:mm");
	}
	
	private JSONObject extract(String content){
		
		JSONObject graph = new JSONObject();
		JSONArray vertices = new JSONArray();
		JSONArray edges = new JSONArray();
		
		JSONObject vertex = new JSONObject();
		
		Document doc = Jsoup.parse(content);
		Element contentBox = doc.getElementsByClass("ContentBox").first();
		logger.debug(contentBox.html());
		
		Element table = contentBox.getElementsByTag("table").last();
		logger.debug("Table Contents: {}", table.outerHtml());
		
		Element headers = table.getElementsByClass("tabletitle").first();
		Elements colTitlesElements = headers.getElementsByTag("td");
		ArrayList<String> colTitles = new ArrayList<String>();
		String currTitle;
		for(int i=0; i<colTitlesElements.size()-1; i++){
			currTitle = colTitlesElements.get(i).text();
			colTitles.add(currTitle);
		}
		colTitles.add("Country"); //last col has flag icons, with no headers.
		logger.info("Col titles found: {}", colTitles);
		
		Elements rows = table.getElementsByTag("tr");
		rows.remove(0); //remove the two header rows
		rows.remove(0);
		logger.debug("Table rows remaining: {}", rows.outerHtml());
		
		String cells[][] = getCells(rows);
		
		TreeSet<String> date = new TreeSet<String>();
		TreeSet<String> urls = new TreeSet<String>();
		TreeSet<String> domain = new TreeSet<String>();
		TreeSet<String> ips = new TreeSet<String>();
		TreeSet<String> reverse_lookup = new TreeSet<String>();
		TreeSet<String> description = new TreeSet<String>();
		TreeSet<String> registrant = new TreeSet<String>();
		TreeSet<String> asn = new TreeSet<String>();
		TreeSet<String> country = new TreeSet<String>();
		
		for(int i=0; i<cells.length; i++){
			String desc = cells[i][4];
			if(desc.equals("-")) desc = "";
			String possibleAVName;
			if(cells[i].length != 8){
				logger.warn("Unexpected length of cells[" + i + "]: " + cells[i].length);
			}
			date.add( Long.toString(convertTimestamp(cells[i][0])));
			if(cells[i][1].equals("-")){//no 'domain' field, which means 'ip' field will contain the actual url
				String urlString = cells[i][2];
				if(urlString.contains(" ")){ //sometimes, the URL field actually contains URL, space, AVName
					possibleAVName = urlString.split(" ")[1];
					//Somewhere around 2% have this, and almost all are missing their desc. field.
					logger.info("Possible AVName found: " + possibleAVName + " from url " + urlString);
					if(desc.length() >0){
						logger.info("previous description was {}", desc);
						desc = possibleAVName + " " + desc;  //Note: this is somewhere around 0.1%
					}else{
						desc = possibleAVName;
					}
					//logger.info(desc);
					urlString = urlString.split(" ")[0];
				}
				urls.add(urlString);
				try {
					String currIP = getDomainFromURL("http://"+urlString); 
					ips.add(currIP);
				} catch (Exception e) {
					logger.warn("Unparsable URL: " + cells[i][2], e);
				}
			}else{
				String urlString = cells[i][1];
				if(urlString.contains(" ")){ //sometimes, the URL field actually contains URL, space, AVName
					possibleAVName = urlString.split(" ")[1];
					//Somewhere around 2% have this, and almost all are missing their desc. field.
					logger.info("Possible AVName found: " + possibleAVName + " from url " + urlString);
					if(desc.length() >0){
						logger.info("previous description was {}", desc);
						desc = possibleAVName + " " + desc;  //Note: this is somewhere around 0.1%
					}else{
						desc = possibleAVName;
					}
					//logger.info(desc);
					urlString = urlString.split(" ")[0];
				}
				urls.add(urlString);
				try {
					String currDomain = getDomainFromURL("http://"+urlString); 
					domain.add(currDomain);
				} catch (Exception e) {
					logger.warn("Unparsable URL: " + cells[i][1], e);
				}
				ips.add(cells[i][2]);
			}
			reverse_lookup.add(cells[i][3]);
			description.add(desc);
			registrant.add(cells[i][5]);
			asn.add(cells[i][6]);
			country.add(cells[i][7]);
		}
		
		
		//malware node stuff...
		String malwareName = "MalwareDomainList_";
		if(domain.size() == 1) malwareName += domain.first();
		else if(ips.size() == 1) malwareName += ips.first();
		else{
			logger.warn("No meaningful name could be generated!");
			Random r = new Random();
			malwareName += r.nextInt(1000000000);//TODO any better ideas?
		}
		vertex.put("name", malwareName);
		vertex.put("_id", malwareName);
		vertex.put("_type", "vertex");
		vertex.put("vertexType", "malware");
		vertex.put("source", "MalwareDomainList");
		if(date.size() == 1){
			vertex.put("date", date.first());
		}else{
			logger.warn("Expected to find one date, but found " + date.size());
		}
		if(urls.size() == 0){ //can have more than one
			logger.warn("Expected to find at least one url, but found none!");
		}else{
			vertex.put("urlsUsed", urls);
		}
		if(description.size() == 0){ //can have more than one
			logger.warn("Expected to find at least one description, but found none!");
		}else{
			vertex.put("description", description);
		}
		vertices.put(vertex);
		
		//DNS node stuff...
		JSONObject dnsVertex = null;
		if(domain.size() > 1){
			logger.warn("Expected to find zero or one domain, but found " + domain.size());
		}else if (domain.size() == 1){
			dnsVertex = new JSONObject();
			dnsVertex.put("name", domain.first());
			dnsVertex.put("_id", domain.first());
			dnsVertex.put("_type", "vertex");
			dnsVertex.put("vertexType", "DNSName");
			dnsVertex.put("source", "MalwareDomainList");
			if(registrant.size() == 1){
				if(!registrant.first().equals("-"))
					dnsVertex.put("registrant", registrant.first());
			}else{
				logger.warn("Expected to find one registrant, but found " + registrant.size());
			}
			vertices.put(dnsVertex);
			
			if(ips.size() == 0){
				//if were are no IPs, we would need to make an 'address' node to connect to.
				//HOWEVER I don't think that will ever happen.
				//TODO: if you ever see this message, revisit this issue.
				logger.warn("Did not find any IPs!  Some edges can not be created!");
			}//if there were IPs found, just make the edges later, after the address node(s) are created.			
		}//else you have no DNS info, which happens sometimes
		
		//reverse DNS stuff...
		JSONObject reverseDnsVertex = null;
		if(reverse_lookup.size() == 1){
			reverseDnsVertex = new JSONObject();
			reverseDnsVertex.put("name", reverse_lookup.first());
			reverseDnsVertex.put("_id", reverse_lookup.first());
			reverseDnsVertex.put("_type", "vertex");
			reverseDnsVertex.put("vertexType", "DNSName");
			reverseDnsVertex.put("source", "MalwareDomainList");
			vertices.put(reverseDnsVertex);
		}else{
			logger.warn("Expected to find one reverse_lookup, but found " + reverse_lookup.size());
		}
		
		
		
		//IP node stuff...
		JSONObject ipVertex = null;
		if(ips.size() == 0){ //can have more than one
			logger.warn("Expected to find at least one ip, but found none!");
		}else{
			for(String ip : ips){
				ipVertex = new JSONObject();
				ipVertex.put("name", ip);
				ipVertex.put("_id", ip);
				ipVertex.put("_type", "vertex");
				ipVertex.put("vertexType", "ip");
				ipVertex.put("source", "MalwareDomainList");
				//asn and country really go in an AddressRange node, 
				//  but we won't know what range to use until alignment can look it up in database
				//TODO: how best to handle this?
				//  leaving it out for now, it *shouldn't* be new info anyway...
				/*
				if(asn.size() == 1){
					ipVertex.put("asNum", asn.first());
				}else{
					logger.warn("Expected to find one asn, but found " + asn.size());
				}		
				if(country.size() == 1){
					ipVertex.put("countryName", country.first());
				}else{
					logger.warn("Expected to find one country, but found " + country.size());
				}
				*/
				vertices.put(ipVertex);
				
				//NOW we can make the address node(s), and make all of the needed edges
				JSONObject addressVertex = new JSONObject();
				String addressName = ip + ":80"; //TODO more robust handling
				if(urls.size() == 0) addressName = ip + ":any"; //should rarely or never happen
				addressVertex.put("name", addressName);
				addressVertex.put("_id", addressName);
				addressVertex.put("_type", "vertex");
				addressVertex.put("vertexType", "Address");
				addressVertex.put("source", "MalwareDomainList");
				vertices.put(addressVertex);
				//'malware' -'communicatesWith'-> 'address'
				JSONObject edge = new JSONObject();
				edge.put("_inV", addressName);
				edge.put("_outV", malwareName);
				edge.put("_id", malwareName + "_to_" + addressName);
				edge.put("_type", "edge");
				edge.put("inVType", "address");
				edge.put("outVType", "malware");
				edge.put("source", "MalwareDomainList");
				edge.put("_label", "communicatesWith");
				edges.put(edge);
				//"description":"'address' -'hasIP'-> 'IP'",
				edge = new JSONObject();
				edge.put("_inV", ip);
				edge.put("_outV", addressName);
				edge.put("_id", addressName + "_to_" + ip);
				edge.put("_type", "edge");
				edge.put("inVType", "ip");
				edge.put("outVType", "address");
				edge.put("source", "MalwareDomainList");
				edge.put("_label", "hasIP");
				edges.put(edge);
				//TODO 'address' -'hasPort'-> 'port' ??
				//"description":"'address' -'hasDNSName'-> 'DNSName'",
				if(dnsVertex != null){
					edge = new JSONObject();
					edge.put("_inV", dnsVertex.get("name"));
					edge.put("_outV", addressName);
					edge.put("_id", addressName + "_to_" + dnsVertex.get("name"));
					edge.put("_type", "edge");
					edge.put("inVType", "DNSName");
					edge.put("outVType", "address");
					edge.put("source", "MalwareDomainList");
					edge.put("_label", "hasDNSName");
					edge.put("reverse", false);
					edges.put(edge);
				}
				//"description":"'address' -'hasDNSName'-> 'DNSName'",
				if(reverseDnsVertex != null){
					edge = new JSONObject();
					edge.put("_inV", reverseDnsVertex.get("name"));
					edge.put("_outV", addressName);
					edge.put("_id", addressName + "_to_" + reverseDnsVertex.get("name"));
					edge.put("_type", "edge");
					edge.put("inVType", "DNSName");
					edge.put("outVType", "address");
					edge.put("source", "MalwareDomainList");
					edge.put("_label", "hasDNSName");
					edge.put("reverse", true);
					edges.put(edge);
				}
			}
		}
		
		
		graph.put("mode","NORMAL");
		graph.put("vertices", vertices);
		graph.put("edges", edges);
		
	    return graph;
	}

}
