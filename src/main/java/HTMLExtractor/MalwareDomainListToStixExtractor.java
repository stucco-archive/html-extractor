package HTMLExtractor;

import java.util.ArrayList;
import java.util.Random;
import java.util.TreeSet;

import org.json.*;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.mitre.stix.stix_1.STIXHeaderType;
import org.mitre.stix.stix_1.STIXPackage;
import org.mitre.stix.ttp_1.BehaviorType;
import org.mitre.stix.ttp_1.MalwareType;
import org.mitre.stix.ttp_1.MalwareInstanceType;
import org.mitre.stix.common_1.ControlledVocabularyStringType;
import org.mitre.stix.stix_1.IndicatorsType;
import org.mitre.stix.common_1.IndicatorBaseType;
import org.mitre.stix.indicator_2.Indicator;
import org.mitre.stix.indicator_2.ValidTimeType;
import org.mitre.stix.ttp_1.VictimTargetingType;
import org.mitre.stix.ttp_1.ResourceType;
import org.mitre.stix.ttp_1.InfrastructureType;
import org.mitre.stix.common_1.StructuredTextType;
import org.mitre.stix.indicator_2.SuggestedCOAsType;
import org.mitre.stix.common_1.RelatedCourseOfActionType;
import org.mitre.stix.common_1.CourseOfActionBaseType;
import org.mitre.stix.courseofaction_1.CourseOfAction;
import org.mitre.cybox.cybox_2.Observable;
import org.mitre.stix.common_1.InformationSourceType;
import org.mitre.stix.common_1.ContributingSourcesType;
import org.mitre.stix.common_1.IdentityType;
import org.mitre.cybox.common_2.TimeType;
import org.mitre.stix.common_1.TTPBaseType;
import org.mitre.stix.ttp_1.TTP;
import org.mitre.stix.common_1.RelatedTTPType;
import org.mitre.stix.ttp_1.BehaviorType;
import org.mitre.stix.ttp_1.AttackPatternsType;
import org.mitre.stix.ttp_1.AttackPatternType;
import org.mitre.stix.common_1.DateTimeWithPrecisionType;
import org.mitre.stix.common_1.ReferencesType;

import javax.xml.datatype.XMLGregorianCalendar;
import javax.xml.datatype.DatatypeFactory;
import javax.xml.namespace.QName;
import java.util.GregorianCalendar;
import java.util.TimeZone;
import java.util.UUID;
import javax.xml.datatype.DatatypeConfigurationException;

public class MalwareDomainListToStixExtractor extends HTMLExtractor{
	
	private STIXPackage stixPackage;

	private JSONObject graph;
	private static final Logger logger = LoggerFactory.getLogger(MalwareDomainListExtractor.class);

	public MalwareDomainListToStixExtractor(String content){
		graph = extract(content);
	}
	
	public JSONObject getGraph() {
		return graph;
	}
	
	private long convertTimestamp(String time)	{ 
		return convertTimestamp(time + " (GMT)", "yyyy/MM/dd_hh:mm (z)");
	}
	
	private JSONObject extract(String content){
	
		try {

		GregorianCalendar calendar = new GregorianCalendar();
			
		XMLGregorianCalendar now = DatatypeFactory.newInstance().newXMLGregorianCalendar(				
			new GregorianCalendar(TimeZone.getTimeZone("UTC")));
		stixPackage = new STIXPackage()				
 			.withSTIXHeader(new STIXHeaderType().
				withTitle("MalwareDomainList")) 
			.withTimestamp(now)
 			.withId(new QName("stucco", "MalwareDomainList-" + UUID.randomUUID().toString(), "stucco"));
								
		JSONObject graph = new JSONObject();
		JSONArray vertices = new JSONArray();
		JSONArray edges = new JSONArray();
		
		JSONObject vertex = new JSONObject();
		
		Document doc = Jsoup.parse(content);
		Element contentBox = doc.getElementsByClass("ContentBox").first();
		logger.debug(contentBox.html());
		
		Element table = contentBox.getElementsByTag("table").last();
		logger.debug("Table Contents: {}", table.outerHtml());
		
		Element headers = table.getElementsByClass("tabletitle").first();
		Elements colTitlesElements = headers.getElementsByTag("td");
		ArrayList<String> colTitles = new ArrayList<String>();
		String currTitle;
		for(int i=0; i<colTitlesElements.size()-1; i++){
			currTitle = colTitlesElements.get(i).text();
			colTitles.add(currTitle);
		}
		colTitles.add("Country"); //last col has flag icons, with no headers.
		logger.info("Col titles found: {}", colTitles);
		
		Elements rows = table.getElementsByTag("tr");
		rows.remove(0); //remove the two header rows
		rows.remove(0);
		logger.debug("Table rows remaining: {}", rows.outerHtml());
		
		String cells[][] = getCells(rows);
		
		TreeSet<Long> date = new TreeSet<Long>();
		TreeSet<String> urls = new TreeSet<String>();
		TreeSet<String> domain = new TreeSet<String>();
		TreeSet<String> ips = new TreeSet<String>();
		TreeSet<String> reverse_lookup = new TreeSet<String>();
		TreeSet<String> description = new TreeSet<String>();
		TreeSet<String> registrant = new TreeSet<String>();
		TreeSet<String> asn = new TreeSet<String>();
		TreeSet<String> country = new TreeSet<String>();
		
		for(int i=0; i<cells.length; i++){
			String desc = cells[i][4];
			if(desc.equals("-")) desc = "";
			String possibleAVName;
			if(cells[i].length != 8){
				logger.warn("Unexpected length of cells[" + i + "]: " + cells[i].length);
			}
			date.add( convertTimestamp(cells[i][0]));
			if(cells[i][1].equals("-")){//no 'domain' field, which means 'ip' field will contain the actual url
				String urlString = cells[i][2];
				if(urlString.contains(" ")){ //sometimes, the URL field actually contains URL, space, AVName
					possibleAVName = urlString.split(" ")[1];
					//Somewhere around 2% have this, and almost all are missing their desc. field.
					logger.info("Possible AVName found: " + possibleAVName + " from url " + urlString);
					if(desc.length() >0){
						logger.info("previous description was {}", desc);
						desc = possibleAVName + " " + desc;  //Note: this is somewhere around 0.1%
					}else{
						desc = possibleAVName;
					}
					//logger.info(desc);
					urlString = urlString.split(" ")[0];
				}
				urls.add(urlString);
				try {
					String currIP = getDomainFromURL("http://"+urlString); 
					ips.add(currIP);
				} catch (Exception e) {
					logger.warn("Unparsable URL: " + cells[i][2], e);
				}
			}else{
				String urlString = cells[i][1];
				if(urlString.contains(" ")){ //sometimes, the URL field actually contains URL, space, AVName
					possibleAVName = urlString.split(" ")[1];
					//Somewhere around 2% have this, and almost all are missing their desc. field.
					logger.info("Possible AVName found: " + possibleAVName + " from url " + urlString);
					if(desc.length() >0){
						logger.info("previous description was {}", desc);
						desc = possibleAVName + " " + desc;  //Note: this is somewhere around 0.1%
					}else{
						desc = possibleAVName;
					}
					//logger.info(desc);
					urlString = urlString.split(" ")[0];
				}
				urls.add(urlString);
				try {
					String currDomain = getDomainFromURL("http://"+urlString); 
					domain.add(currDomain);
				} catch (java.net.URISyntaxException e) {
					logger.warn("Unparsable URL: " + cells[i][1]);
				}
				ips.add(cells[i][2]);
			}
			reverse_lookup.add(cells[i][3]);
			description.add(desc);
			registrant.add(cells[i][5]);
			asn.add(cells[i][6]);
			country.add(cells[i][7]);
		}
		
		
		//malware node stuff...
		String malwareName = "MalwareDomainList_";
		if(domain.size() == 1) malwareName += domain.first();
		else if(ips.size() == 1) malwareName += ips.first();
		else{
			logger.warn("No meaningful name could be generated!");
			Random r = new Random();
			malwareName += r.nextInt(1000000000);//TODO any better ideas?
		}
		
		MalwareInstanceType malware = new MalwareInstanceType();
		Indicator indicator = new Indicator();
		InformationSourceType source = new InformationSourceType();
		

		vertex.put("name", malwareName);
		//name as Indicator->TTP->Behavior->Malware->name
		malware
			.withNames(new ControlledVocabularyStringType()
				.withValue(malwareName));

		//no id entree in stix, but it always the same as manlwareName
		vertex.put("_id", malwareName);
		//no _type in stix
		vertex.put("_type", "vertex");
	
		vertex.put("vertexType", "malware");
		
		vertex.put("source", "MalwareDomainList");

		//source as Indicator->TTP->InformationSourceType->source
		
		source
			.withContributingSources(new ContributingSourcesType()
				.withSources(new InformationSourceType()
					.withIdentity(new IdentityType()
						 .withName("F-Secure"))));

		if(date.size() == 1){
			vertex.put("date", date.first());
			
			calendar.setTimeInMillis(date.first());
			XMLGregorianCalendar startDate = DatatypeFactory.newInstance().newXMLGregorianCalendar(calendar);
			
			//date as Indicator->Valid_Time_Position->Start_Time
			indicator
				.withValidTimePositions(new ValidTimeType()
					.withStartTime(new DateTimeWithPrecisionType()
						.withValue(startDate)));
		}else{
			logger.warn("Expected to find one date, but found " + date.size());
		}
		if(urls.size() == 0){ //can have more than one
			logger.warn("Expected to find at least one url, but found none!");
		}else{
			vertex.put("urlsUsed", urls);

			//urlsUsed as Indicator->TTP->Information_Source->References
			source
				.withReferences(new ReferencesType()
					.withReferences(urls));

		}
		if(description.size() == 0){ //can have more than one
			logger.warn("Expected to find at least one description, but found none!");
		}else{
			String desc = "";
			for(String item : description){
				desc += item + ", ";
			}
			desc = (String) desc.subSequence(0, desc.length()-2);
			vertex.put("description", desc);

			malware
				.withDescriptions(new StructuredTextType()
					.withValue(desc));
		}
		vertices.put(vertex);
		
		indicator
			.withTypes(new ControlledVocabularyStringType()
				.withValue("Malware"))
			.withIndicatedTTPs(new RelatedTTPType()
				.withTTP(new TTP()
					.withBehavior(new BehaviorType()
						.withMalware(new MalwareType()
							.withMalwareInstances(malware)))
					.withInformationSource(source)));
		
		stixPackage 				
			.withIndicators(new IndicatorsType().withIndicators(indicator));
		

		//DNS node stuff...
		JSONObject dnsVertex = null;

		Observable observable = new Observable();

		if(domain.size() > 1){
			logger.warn("Expected to find zero or one domain, but found " + domain.size());
		}else if (domain.size() == 1){
			dnsVertex = new JSONObject();
			dnsVertex.put("name", domain.first());
			dnsVertex.put("description", domain.first());
			dnsVertex.put("_id", domain.first());
			dnsVertex.put("_type", "vertex");
			dnsVertex.put("vertexType", "DNSName");
			dnsVertex.put("source", "MalwareDomainList");
			if(registrant.size() == 1){
				if(!registrant.first().equals("-"))
					dnsVertex.put("registrant", registrant.first());
			}else{
				logger.warn("Expected to find one registrant, but found " + registrant.size());
			}
			vertices.put(dnsVertex);
			
			if(ips.size() == 0){
				//if were are no IPs, we would need to make an 'address' node to connect to.
				//HOWEVER I don't think that will ever happen.
				//TODO: if you ever see this message, revisit this issue.
				logger.warn("Did not find any IPs!  Some edges can not be created!");
			}//if there were IPs found, just make the edges later, after the address node(s) are created.			
		}//else you have no DNS info, which happens sometimes
		
		//reverse DNS stuff...
		JSONObject reverseDnsVertex = null;
		if(reverse_lookup.size() == 1){
			reverseDnsVertex = new JSONObject();
			reverseDnsVertex.put("name", reverse_lookup.first());
			reverseDnsVertex.put("description", reverse_lookup.first());
			reverseDnsVertex.put("_id", reverse_lookup.first());
			reverseDnsVertex.put("_type", "vertex");
			reverseDnsVertex.put("vertexType", "DNSName");
			reverseDnsVertex.put("source", "MalwareDomainList");
			vertices.put(reverseDnsVertex);
		}else{
			logger.warn("Expected to find one reverse_lookup, but found " + reverse_lookup.size());
		}
		
		
		
		//IP node stuff...
		JSONObject ipVertex = null;
		if(ips.size() == 0){ //can have more than one
			logger.warn("Expected to find at least one ip, but found none!");
		}else{
			for(String ip : ips){
				ipVertex = new JSONObject();
				ipVertex.put("name", ip);
				ipVertex.put("description", ip);
				ipVertex.put("_id", ip);
				ipVertex.put("_type", "vertex");
				ipVertex.put("vertexType", "ip");
				ipVertex.put("source", "MalwareDomainList");
				//asn and country really go in an AddressRange node, 
				//  but we won't know what range to use until alignment can look it up in database
				//TODO: how best to handle this?
				//  leaving it out for now, it *shouldn't* be new info anyway...
				/*
				if(asn.size() == 1){
					ipVertex.put("asNum", asn.first());
				}else{
					logger.warn("Expected to find one asn, but found " + asn.size());
				}		
				if(country.size() == 1){
					ipVertex.put("countryName", country.first());
				}else{
					logger.warn("Expected to find one country, but found " + country.size());
				}
				*/
				vertices.put(ipVertex);
				
				//NOW we can make the address node(s), and make all of the needed edges
				JSONObject addressVertex = new JSONObject();
				String addressName = ip + ":80"; //TODO more robust handling
				String addressDesc = ip + ", port 80"; //TODO more robust handling
				if(urls.size() == 0) addressName = ip + ":any"; //should rarely or never happen
				addressVertex.put("name", addressName);
				addressVertex.put("description", addressDesc);
				addressVertex.put("_id", addressName);
				addressVertex.put("_type", "vertex");
				addressVertex.put("vertexType", "Address");
				addressVertex.put("source", "MalwareDomainList");
				vertices.put(addressVertex);
				//'malware' -'communicatesWith'-> 'address'
				JSONObject edge = new JSONObject();
				edge.put("_inV", addressName);
				edge.put("_outV", malwareName);
				edge.put("_id", malwareName + "_communicatesWith_" + addressName);
				edge.put("description", malwareName + " communicates with " + addressDesc);
				edge.put("_type", "edge");
				edge.put("inVType", "address");
				edge.put("outVType", "malware");
				edge.put("source", "MalwareDomainList");
				edge.put("_label", "communicatesWith");
				edges.put(edge);
				//"description":"'address' -'hasIP'-> 'IP'",
				edge = new JSONObject();
				edge.put("_inV", ip);
				edge.put("_outV", addressName);
				edge.put("_id", addressName + "_hasIP_" + ip);
				edge.put("description", addressDesc + " has IP " + ip);
				edge.put("_type", "edge");
				edge.put("inVType", "ip");
				edge.put("outVType", "address");
				edge.put("source", "MalwareDomainList");
				edge.put("_label", "hasIP");
				edges.put(edge);
				//TODO 'address' -'hasPort'-> 'port' ??
				//"description":"'address' -'hasDNSName'-> 'DNSName'",
				if(dnsVertex != null){
					edge = new JSONObject();
					edge.put("_inV", dnsVertex.get("name"));
					edge.put("_outV", addressName);
					edge.put("_id", addressName + "_hasDNSName_" + dnsVertex.get("name"));
					edge.put("description", addressDesc + " has DNS name " + dnsVertex.get("name"));
					edge.put("_type", "edge");
					edge.put("inVType", "DNSName");
					edge.put("outVType", "address");
					edge.put("source", "MalwareDomainList");
					edge.put("_label", "hasDNSName");
					edge.put("reverse", false);
					edges.put(edge);
				}
				//"description":"'address' -'hasDNSName'-> 'DNSName'",
				if(reverseDnsVertex != null){
					edge = new JSONObject();
					edge.put("_inV", reverseDnsVertex.get("name"));
					edge.put("_outV", addressName);
					edge.put("_id", addressName + "_hasDNSName_" + reverseDnsVertex.get("name"));
					edge.put("description", addressDesc + " has DNS name " + reverseDnsVertex.get("name"));
					edge.put("_type", "edge");
					edge.put("inVType", "DNSName");
					edge.put("outVType", "address");
					edge.put("source", "MalwareDomainList");
					edge.put("_label", "hasDNSName");
					edge.put("reverse", true);
					edges.put(edge);
				}
			}
		}
		
		
		graph.put("mode","NORMAL");
		graph.put("vertices", vertices);
		graph.put("edges", edges);
		
	    return graph;

		} catch (DatatypeConfigurationException e)      {
			 e.printStackTrace();
		}
		
		return null;
	}

}
